# Алгоритм коррекции дуг 180° для постпроцессоров

## Дата создания: 2025-01-01

## Проблема

### Описание проблемы

Проблема с обработкой дуг 180° встречается в **90% всех постпроцессоров**. Основные симптомы:

1. **Отрицательные значения `real_correction`**: Даже после коррекции может возникать `-0.00000000` из-за ошибок округления
2. **Невозможные геометрические параметры**: Радиус дуги 180° меньше минимально допустимого (`chord_length / 2`)
3. **Ошибки в выходных файлах**: Некорректные дуги приводят к ошибкам в станках с ЧПУ

### Математическая суть проблемы

Для дуги 180°:
- Начальная и конечная точки являются диаметрально противоположными на окружности
- Центр дуги лежит на середине хорды
- **Минимальный радиус = `chord_length / 2`** (строгое равенство для идеальной дуги 180°)

**Пример невозможной дуги:**
- Из точки (0,0) в точку (100,0) нельзя провести дугу радиусом 49.999 мм
- Минимальный радиус должен быть 50.0 мм

### Источники ошибок

1. **Ошибки округления** в исходных данных (G-код)
2. **Неточности вычислений** при преобразовании координат
3. **Накопление ошибок** при последовательных вычислениях
4. **Округление до точности системы** (например, 0.001 мм)

---

## Решение: Многоступенчатый алгоритм коррекции

### Общая схема алгоритма

```
1. Вычисление реальной геометрии дуги
2. Получение радиуса из исходных данных
3. Проверка соответствия геометрии
4. Расчет длины хорды
5. Итеративная коррекция для дуг 180°
6. Финальная гарантия неотрицательного real_correction
7. Пропуск невалидных дуг
```

---

## Детальное описание шагов

### STEP 1: Вычисление реальной геометрии дуги

**Цель:** Определить, каким должен быть радиус на основе координат точек.

```python
# Вычисляем радиусы от центра до начальной и конечной точек
radius_from_start = sqrt((start_x - center_x)² + (start_y - center_y)²)
radius_to_end = sqrt((end_x - center_x)² + (end_y - center_y)²)
```

**Проверка:** Если разница между радиусами > 0.001 мм → ошибка геометрии.

**Действие:** Использовать среднее значение радиусов.

---

### STEP 2: Получение радиуса из исходных данных

**Цель:** Получить радиус из элемента или вычислить из геометрии.

```python
initial_radius = element.get('r', 0.0)
if initial_radius <= 0.001:
    # Нет радиуса в данных, вычисляем из геометрии
    initial_radius = (radius_from_start + radius_to_end) / 2.0

radius = initial_radius
```

**Важно:** Сохранить `initial_radius` для последующего сравнения (определение коррекции).

---

### STEP 3: Проверка соответствия геометрии

**Цель:** Убедиться, что радиус соответствует реальной геометрии.

```python
radius_avg = (radius_from_start + radius_to_end) / 2.0
radius_diff_start = abs(radius - radius_from_start)
radius_diff_end = abs(radius - radius_to_end)

if radius_diff_start > 0.001 or radius_diff_end > 0.001:
    # Радиус не соответствует геометрии, пересчитываем
    radius = radius_avg
```

**Порог:** 0.001 мм (точность системы).

---

### STEP 4: Расчет длины хорды

**Цель:** Вычислить расстояние между начальной и конечной точками.

```python
chord_length = sqrt((end_x - start_x)² + (end_y - start_y)²)
```

**Использование:** Для проверки выполнимости дуги 180°.

---

### STEP 5: Итеративная коррекция для дуг 180°

**Цель:** Гарантировать, что радиус достаточен для дуги 180°.

**Условие:** `abs(arc_angle - π) < 0.001` (дуга ≈ 180°)

**Алгоритм:**

```python
if abs(arc_angle - math.pi) < 0.001:  # Дуга 180°
    iteration = 0
    max_iterations = 10
    
    # Итеративная коррекция до выполнения условия
    while chord_length - 2 * radius > 0.0001 and iteration < max_iterations:
        radius = chord_length / 2.0 + 0.001  # Минимум + запас
        iteration += 1
    
    # Финальная гарантия с запасом 0.001 мм
    min_required_radius = chord_length / 2.0 + 0.001
    if radius < min_required_radius:
        radius = min_required_radius
```

**Ключевые моменты:**
- Условие цикла: `chord_length - 2 * radius > 0.0001`
- Коррекция: `radius = chord_length / 2.0 + 0.001`
- Защита от бесконечного цикла: максимум 10 итераций
- Финальная гарантия: запас 0.001 мм

---

### STEP 6: Финальная гарантия неотрицательного `real_correction`

**Цель:** Убедиться, что `real_correction = 2 * radius - chord_length >= 0`.

**Алгоритм:**

```python
# Вычисляем real_correction
real_correction = 2 * radius - chord_length

if abs(arc_angle - math.pi) < 0.001:  # Дуга 180°
    if real_correction < 0:
        # Дополнительная коррекция
        radius = chord_length / 2.0 + abs(real_correction) / 2.0 + 0.001
        real_correction = 2 * radius - chord_length
    
    # Гарантия неотрицательного значения (обработка -0.00000000)
    real_correction = max(0.0, real_correction)
```

**Важно:**
- Запас 0.001 мм для учета ошибок округления
- Использование `max(0.0, real_correction)` для обработки `-0.00000000`
- Дополнительная коррекция при необходимости

---

### STEP 7: Пропуск невалидных дуг

**Цель:** Пропустить дуги, которые невозможно исправить.

```python
if radius < 0.001:
    # Радиус слишком мал, пропускаем дугу
    continue  # Пропустить элемент
```

**Порог:** 0.001 мм (минимальная точность системы).

---

## Параметры алгоритма

### Пороги и допуски

| Параметр | Значение | Назначение |
|----------|----------|------------|
| `PRECISION` | 3 (0.001 мм) | Точность системы |
| Запас коррекции | 0.001 мм | Запас для учета ошибок округления |
| Порог геометрии | 0.001 мм | Максимальная разница радиусов |
| Порог угла 180° | 0.001 рад | Допуск для определения дуги 180° |
| Условие цикла | 0.0001 мм | Точность выполнения условия |
| Максимум итераций | 10 | Защита от бесконечного цикла |
| Минимальный радиус | 0.001 мм | Порог для пропуска дуги |

---

## Примеры работы алгоритма

### Пример 1: Нормальная дуга 180°

**Исходные данные:**
- Начальная точка: (0, 0)
- Конечная точка: (100, 0)
- Радиус из данных: 50.0 мм
- Угол: 180°

**Обработка:**
1. `chord_length = 100.0 мм`
2. `radius = 50.0 мм`
3. Проверка: `2 * 50.0 = 100.0 >= 100.0` ✓
4. `real_correction = 2 * 50.0 - 100.0 = 0.0` ✓

**Результат:** Коррекция не требуется, `real_correction = 0.0`

---

### Пример 2: Дуга 180° с недостаточным радиусом

**Исходные данные:**
- Начальная точка: (0, 0)
- Конечная точка: (100, 0)
- Радиус из данных: 49.999 мм (из-за округления)
- Угол: 180°

**Обработка:**
1. `chord_length = 100.0 мм`
2. `radius = 49.999 мм`
3. Проверка: `2 * 49.999 = 99.998 < 100.0` ✗
4. **Коррекция:** `radius = 100.0 / 2.0 + 0.001 = 50.001 мм`
5. `real_correction = 2 * 50.001 - 100.0 = 0.002 мм` ✓

**Результат:** Радиус скорректирован, `real_correction = 0.002 мм` (положительное значение)

---

### Пример 3: Дуга 180° с ошибками округления

**Исходные данные:**
- Начальная точка: (0, 0)
- Конечная точка: (100.0001, 0) (округление)
- Радиус из данных: 50.0 мм
- Угол: 180°

**Обработка:**
1. `chord_length = 100.0001 мм` (из-за округления)
2. `radius = 50.0 мм`
3. Проверка: `2 * 50.0 = 100.0 < 100.0001` ✗
4. **Коррекция:** `radius = 100.0001 / 2.0 + 0.001 = 50.00055 мм`
5. `real_correction = 2 * 50.00055 - 100.0001 = 0.001 мм` ✓

**Результат:** Радиус скорректирован с учетом ошибок округления

---

## Применение в других программах

### Адаптация алгоритма

1. **Определить точность системы** (аналог `PRECISION`)
2. **Установить пороги** в соответствии с точностью
3. **Реализовать шаги 1-7** с учетом специфики формата вывода
4. **Добавить логирование** для диагностики

### Ключевые принципы

1. **Многоступенчатая проверка**: Не полагаться на одну проверку
2. **Итеративная коррекция**: Повторять до выполнения условия
3. **Запас для округления**: Всегда добавлять запас 0.001 мм (или соответствующий точности системы)
4. **Гарантия неотрицательности**: Использовать `max(0.0, value)` для финальных значений
5. **Пропуск невалидных**: Лучше пропустить, чем вывести некорректные данные

---

## Преимущества алгоритма

1. **Надежность**: Гарантирует валидные дуги 180°
2. **Устойчивость к ошибкам**: Учитывает ошибки округления
3. **Универсальность**: Применим к любым постпроцессорам
4. **Диагностика**: Логирование позволяет отслеживать коррекции
5. **Производительность**: Ограничение итераций предотвращает бесконечные циклы

---

## История версий

- **v0.23** (2025-01-01): Первая реализация алгоритма коррекции дуг 180°
- **v0.24** (2025-01-01): Увеличен запас до 0.001 мм, добавлена финальная гарантия неотрицательного `real_correction`

---

## Ссылки

- Основной постпроцессор: `woodwop_post.py`
- Документация: `README.md`, `USAGE_GUIDE.md`
- Примеры файлов анализа: `*_processing_analysis.txt`

---

## Автор

Алгоритм разработан для FreeCAD WoodWOP Post-Processor и может быть применен в других постпроцессорах.

